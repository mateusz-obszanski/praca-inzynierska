"""
New population generators.
"""


from typing import TypedDict
import more_itertools as mit

from . import Population
from .parent_selectors import ParentSelector, sort_population
from .population_selectors import PopulationSelector
from ..operators.mutations import Mutator
from ..operators.crossovers import Crossover
from ..operators.fixers import ChromosomeFixer, FixResult
from .....environment import Environment
from .....environment.cost import CostCalculator
from .....environment.cost.base import CostT


class PopulationGenerationData(TypedDict):
    parent_costs: list[CostT]
    new_costs: list[CostT]
    did_mutate: dict[Mutator, list[bool]]


class PopulationGenerator:
    @staticmethod
    def generate(
        old_population: Population,
        environment: Environment,
        cost_calculator: CostCalculator,
        parent_selector: ParentSelector,
        mutators: list[Mutator],
        crossover: Crossover,
        fixers: list[ChromosomeFixer],
        old_population_prev_fix_results: list[FixResult],
    ) -> tuple[Population, PopulationGenerationData]:
        """
        Generates new population from the old one using provided mutators,
        crossovers and fixers. If certain offspring cannot be fixed, takes
        better mutated parent instead (or two if both children are unrecoverable).

        New generation is selected by fitness to be the same size as the old one.

        Assumes that population size is even.

        `old_population_prev_fix_results` for the first time can be set to all
        successes or generated by mapping fixer onto old_population.
        """

        population_size = len(old_population)

        assert population_size % 2 == 0

        population_to_be_mutated: Population = old_population
        did_mutate: list[bool] = []
        mutation_data = {}

        for mutator in mutators:
            population_to_be_mutated, did_mutate = mit.unzip(
                mutator.mutate(chromosome) for chromosome in population_to_be_mutated  # type: ignore
            )

            mutation_data[mutator] = did_mutate

        parents, parent_costs = parent_selector.select(
            old_population, environment, cost_calculator
        )

        new_generation = mit.flatten(
            crossover.execute(parent1, parent2) for parent1, parent2 in parents
        )

        # sorted_new_generation, new_costs = sort_population(
        #     new_generation, environment, cost_calculator
        # )

        # TODO save the best solution from the new generation (the old generation's is saved in previous iteration)
        # selected_new_generation = sorted_new_generation[:population_size]
        # selected_costs = new_costs[:population_size]
        # TODO use fixers
        # TODO use population selector

        generation_data = {
            "parent_costs": parent_costs,
            "new_costs": selected_costs,
            "did_mutate": did_mutate,
        }
